<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyPPG.FiducialPoints &mdash; pyPPG 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyPPG
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">pyPPG</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/pyPPG_analysis.html">PPG morphological analysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyPPG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyPPG.FiducialPoints</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyPPG.FiducialPoints</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">pack_ppg._ErrorHandler</span> <span class="kn">import</span> <span class="n">_check_shape_</span><span class="p">,</span> <span class="n">WrongParameter</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">dotmap</span> <span class="kn">import</span> <span class="n">DotMap</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">kaiserord</span><span class="p">,</span> <span class="n">firwin</span><span class="p">,</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">periodogram</span><span class="p">,</span> <span class="n">lfilter</span><span class="p">,</span> <span class="n">find_peaks</span><span class="p">,</span> <span class="n">firls</span><span class="p">,</span> <span class="n">resample</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

<div class="viewcode-block" id="FiducialPoints"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints">[docs]</a><span class="k">class</span> <span class="nc">FiducialPoints</span><span class="p">:</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">###################### Initialization of Fiducial Points ##################</span>
    <span class="c1">###########################################################################</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The purpose of the FiducialPoints class is to calculate the fiducial points.</span>

<span class="sd">        :param s: a struct of PPG signal:</span>
<span class="sd">            - s.v: a vector of PPG values</span>
<span class="sd">            - s.fs: the sampling frequency of the PPG in Hz</span>
<span class="sd">            - s.name: name of the record</span>
<span class="sd">            - s.v: 1-d array, a vector of PPG values</span>
<span class="sd">            - s.fs: the sampling frequency of the PPG in Hz</span>
<span class="sd">            - s.filt_sig: 1-d array, a vector of the filtered PPG values</span>
<span class="sd">            - s.filt_d1: 1-d array, a vector of the filtered PPG&#39; values</span>
<span class="sd">            - s.filt_d2: 1-d array, a vector of the filtered PPG&quot; values</span>
<span class="sd">            - s.filt_d3: 1-d array, a vector of the filtered PPG&#39;&quot; values</span>
<span class="sd">        :type s: DotMap</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">fs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongParameter</span><span class="p">(</span><span class="s2">&quot;Sampling frequency should be strictly positive&quot;</span><span class="p">)</span>
        <span class="n">_check_shape_</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

        <span class="n">keys</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">keys_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keys_list</span><span class="p">:</span>
            <span class="n">exec</span><span class="p">(</span><span class="s1">&#39;self.&#39;</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="s1">&#39; = s[i]&#39;</span><span class="p">)</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">############################ Get Fiducial Points ##########################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.getFiducialPoints"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.getFiducialPoints">[docs]</a>    <span class="k">def</span> <span class="nf">getFiducialPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">correct</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;The function calculates the PPG Fiducial Points.</span>
<span class="sd">            - Original signal: List of pulse onset, pea and dicrotic notch</span>
<span class="sd">            - 1st derivative: List of points of 1st maximum and minimum in 1st derivitive between the onset to onset intervals (u,v)</span>
<span class="sd">            - 2nd derivative: List of maximum and minimum points in 2nd derivitive between the onset to onset intervals (a, b, c, d, e)</span>

<span class="sd">        :param correct: a bool for fiducials points corretion</span>
<span class="sd">        :type correct: bool</span>

<span class="sd">        :return: fiducial points, a dictionary where the key is the name of the fiducial pints and the value is the list of fiducial points.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># &#39;abp&#39; refers the improved Aboy++, and &#39;aby&#39; refers the original Aboy peak detector</span>
        <span class="n">peak_detector</span><span class="o">=</span><span class="s1">&#39;abp&#39;</span>

        <span class="c1"># Extract Fiducial Points</span>
        <span class="n">drt0_fp</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">peaks</span><span class="p">,</span> <span class="n">onsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abdp_beat_detector</span><span class="p">(</span><span class="n">peak_detector</span><span class="p">)</span>
        <span class="n">dicroticnotch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDicroticNotch</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">onsets</span><span class="p">)</span>

        <span class="n">drt1_fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFirstDerivitivePoints</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span>
        <span class="n">drt2_fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSecondDerivitivePoints</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">peaks</span><span class="p">)</span>
        <span class="n">drt3_fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getThirdDerivitivePoints</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="p">)</span>

        <span class="n">diastolicpeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDiastolicPeak</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">dicroticnotch</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>

        <span class="c1"># Merge Fiducial Points</span>
        <span class="n">keys</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">,</span> <span class="s1">&#39;sp&#39;</span><span class="p">,</span> <span class="s1">&#39;dn&#39;</span><span class="p">,</span><span class="s1">&#39;dp&#39;</span><span class="p">)</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">))</span>
        <span class="n">dummy</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">temp_val</span> <span class="ow">in</span> <span class="p">(</span><span class="n">onsets</span><span class="p">,</span><span class="n">peaks</span><span class="p">,</span><span class="n">dicroticnotch</span><span class="p">,</span><span class="n">diastolicpeak</span><span class="p">):</span>
            <span class="n">drt0_fp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dummy</span>
            <span class="n">drt0_fp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">n</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">temp_val</span><span class="p">)]</span><span class="o">=</span><span class="n">temp_val</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">fiducials</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">temp_drt</span> <span class="ow">in</span> <span class="p">(</span><span class="n">drt0_fp</span><span class="p">,</span><span class="n">drt1_fp</span><span class="p">,</span><span class="n">drt2_fp</span><span class="p">,</span><span class="n">drt3_fp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">temp_drt</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">fiducials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dummy</span>
                <span class="n">temp_val</span> <span class="o">=</span> <span class="n">temp_drt</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">fiducials</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">temp_val</span><span class="p">)]</span><span class="o">=</span><span class="n">temp_val</span>

        <span class="c1"># Correct Fiducial Points</span>
        <span class="k">if</span> <span class="n">correct</span><span class="p">:</span>
            <span class="n">fiducials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">CorrectFiducialPoints</span><span class="p">(</span><span class="n">fiducials</span><span class="p">)</span>

        <span class="n">fiducials</span><span class="o">=</span><span class="n">fiducials</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;Int64&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fiducials</span></div>


    <span class="c1">###########################################################################</span>
    <span class="c1">############################ PPG beat detector ############################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.abdp_beat_detector"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.abdp_beat_detector">[docs]</a>    <span class="k">def</span> <span class="nf">abdp_beat_detector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak_detector</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;ABDP_BEAT_DETECTOR detects beats in a photoplethysmogram (PPG) signal</span>
<span class="sd">        using the improved &#39;Automatic Beat Detection&#39; of Aboy M et al.</span>

<span class="sd">        :param peak_detector: type of peak detector</span>
<span class="sd">        :type peak_detector: str</span>

<span class="sd">        :return:</span>
<span class="sd">            - peaks, 1-d array: indices of detected systolic peaks</span>
<span class="sd">            - onsets, 1-d array: indices of detected pulse onsets</span>

<span class="sd">        Reference</span>
<span class="sd">        ---------</span>
<span class="sd">        Aboy M et al., An automatic beat detection algorithm for pressure signals.</span>
<span class="sd">        IEEE Trans Biomed Eng 2005; 52: 1662 - 70. &lt;https://doi.org/10.1109/TBME.2005.855725&gt;</span>

<span class="sd">        Author:</span>
<span class="sd">        Marton A. Goda – Faculty of Biomedical Engineering,</span>
<span class="sd">        Technion – Israel Institute of Technology, Haifa, Israel (August 2022)</span>

<span class="sd">        Original Matlab implementation:</span>
<span class="sd">        Peter H. Charlton – King&#39;s College London (August 2017) – University of Cambridge (February 2022)</span>
<span class="sd">        &lt;https://github.com/peterhcharlton/ppg-beats&gt;</span>

<span class="sd">        Changes from Charlton&#39;s implementation:</span>
<span class="sd">            1) Detect Maxima:</span>
<span class="sd">                *  Systolic peak-to-peak distance is predicted by the heart rate estimate over the preceding 10 sec window.</span>
<span class="sd">                *  The peak location is estimated by distances and prominences of the previous peaks.</span>
<span class="sd">            2) Find Onsets:</span>
<span class="sd">                *  The onset is a local minimum, which is always calculated from the peak that follows it within a given time window</span>
<span class="sd">            3) Tidy of Peaks and Onsets:</span>
<span class="sd">                *  There is a one-to-one correspondence between onsets and peaks</span>
<span class="sd">                *  There are only onset and peak pairs</span>
<span class="sd">                *  The distance between the onset and peak pairs can&#39;t be smaller than 30 ms</span>
<span class="sd">            4) Correct Peaks and Onsets:</span>
<span class="sd">                * The Peaks must be the highest amplitude between two consecutive pulse onsets, if not, then these are corrected</span>
<span class="sd">                * After the correction of Peaks, the Onsets are recalculated</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># inputs</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">)</span>                    <span class="c1">#signal</span>
        <span class="n">fso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mi">75</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="n">fso</span><span class="p">)))</span>
        <span class="n">up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_up_abdp_algorithm</span><span class="p">()</span>                 <span class="c1">#settings</span>
        <span class="n">win_sec</span><span class="o">=</span><span class="mi">10</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">*</span> <span class="n">win_sec</span>                                    <span class="c1">#window length(number of samples)</span>
        <span class="n">win_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">round</span><span class="p">(</span><span class="mf">0.8</span><span class="o">*</span><span class="n">w</span><span class="p">))))</span>
        <span class="n">win_starts</span> <span class="o">=</span> <span class="n">win_starts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">win_starts</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span><span class="p">])[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">win_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">win_starts</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">win_starts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span>

        <span class="c1"># before pre-processing</span>
        <span class="n">hr_win</span><span class="o">=</span><span class="mi">0</span>  <span class="c1">#the estimated systolic peak-to-peak distance, initially it is 0</span>
        <span class="n">hr_win_v</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DetectMaxima</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hr_win</span><span class="p">,</span> <span class="n">peak_detector</span><span class="p">)</span> <span class="c1"># detect all maxima</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">px</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">onsets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">onsets</span>

        <span class="c1"># detect peaks in windows</span>
        <span class="n">all_p4</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_hr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">win_starts</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">all_hr</span> <span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">hr_past</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># the actual heart rate</span>
        <span class="n">hrvi</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># heart rate variability index</span>

        <span class="k">for</span> <span class="n">win_no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">win_starts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">curr_els</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">],</span><span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">curr_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">curr_els</span><span class="p">]</span>

            <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bandpass</span><span class="p">(</span><span class="n">curr_x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">up</span><span class="o">.</span><span class="n">fl_hz</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">up</span><span class="o">.</span><span class="n">fh_hz</span><span class="p">)</span>   <span class="c1"># Filter no.1</span>
            <span class="n">hr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EstimateHeartRate</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">hr_past</span><span class="p">)</span>               <span class="c1"># Estimate HR from weakly filtered signal</span>
            <span class="n">hr_past</span><span class="o">=</span><span class="n">hr</span>
            <span class="n">all_hr</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">hr</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">peak_detector</span><span class="o">==</span><span class="s1">&#39;abp&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hr</span><span class="o">&gt;</span><span class="mi">40</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">win_no</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DetectMaxima</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hr_win</span><span class="p">,</span> <span class="n">peak_detector</span><span class="p">)</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="mi">50</span><span class="p">)</span>
                    <span class="n">pks_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
                    <span class="n">pks_diff</span> <span class="o">=</span> <span class="n">pks_diff</span><span class="p">[</span><span class="n">pks_diff</span><span class="o">&gt;=</span><span class="n">tr</span><span class="p">]</span>
                    <span class="n">hrvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">pks_diff</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pks_diff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span>

                <span class="n">hr_win</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">hrvi</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">hr_win_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hr_win</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hr_win</span><span class="o">=</span><span class="mi">0</span>

            <span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bandpass</span><span class="p">(</span><span class="n">curr_x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">up</span><span class="o">.</span><span class="n">fl_hz</span><span class="p">,</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">hr</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span>              <span class="c1"># Filter no.2</span>
            <span class="n">y2_deriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EstimateDeriv</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>                                          <span class="c1"># Estimate derivative from highly filtered signal</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DetectMaxima</span><span class="p">(</span><span class="n">y2_deriv</span><span class="p">,</span> <span class="n">up</span><span class="o">.</span><span class="n">deriv_threshold</span><span class="p">,</span><span class="n">hr_win</span><span class="p">,</span> <span class="n">peak_detector</span><span class="p">)</span> <span class="c1"># Detect maxima in derivative</span>
            <span class="n">y3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bandpass</span><span class="p">(</span><span class="n">curr_x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">up</span><span class="o">.</span><span class="n">fl_hz</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">hr</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DetectMaxima</span><span class="p">(</span><span class="n">y3</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">hr_win</span><span class="p">,</span> <span class="n">peak_detector</span><span class="p">)</span>                      <span class="c1"># Detect maxima in moderately filtered signal</span>
            <span class="n">p4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_pulse_peaks</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">)</span>
            <span class="n">p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">p4</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">peak_detector</span><span class="o">==</span><span class="s1">&#39;abp&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p4</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">round</span><span class="p">(</span><span class="n">win_sec</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">pks_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">p4</span><span class="p">)</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pks_diff</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
                    <span class="n">pks_diff</span> <span class="o">=</span> <span class="n">pks_diff</span><span class="p">[</span><span class="n">pks_diff</span> <span class="o">&gt;=</span> <span class="n">tr</span><span class="p">]</span>

                    <span class="n">med_hr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">all_hr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_hr</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)])</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">med_hr</span><span class="o">*</span><span class="mf">0.5</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pks_diff</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">med_hr</span><span class="o">*</span><span class="mf">1.5</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pks_diff</span><span class="p">))):</span>
                        <span class="n">hrvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">pks_diff</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pks_diff</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>

            <span class="n">all_p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">all_p4</span><span class="p">,</span> <span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span> <span class="o">+</span> <span class="n">p4</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">all_p4</span><span class="o">=</span><span class="n">all_p4</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">all_p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_p4</span><span class="p">)</span>

        <span class="n">peaks</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">IBICorrect</span><span class="p">(</span><span class="n">all_p4</span><span class="p">,</span> <span class="n">px</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">all_hr</span><span class="p">),</span> <span class="n">fs</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>

        <span class="n">peaks</span> <span class="o">=</span> <span class="p">(</span><span class="n">all_p4</span><span class="o">/</span><span class="n">fs</span><span class="o">*</span><span class="n">fso</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">onsets</span><span class="p">,</span> <span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_onsets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">,</span> <span class="n">fso</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span><span class="mi">60</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">all_hr</span><span class="p">)</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>

        <span class="c1"># Correct Peaks</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">max_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">[</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">max_loc</span><span class="p">:</span>
                <span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_loc</span>

        <span class="c1"># Correct onsets</span>
        <span class="n">onsets</span><span class="p">,</span> <span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_onsets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">,</span> <span class="n">fso</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="mi">60</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">all_hr</span><span class="p">)</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>

        <span class="n">temp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">temp_i</span><span class="p">)</span>
            <span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">temp_i</span><span class="p">)</span>

        <span class="n">temp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">peaks</span> <span class="o">-</span> <span class="n">onsets</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fso</span> <span class="o">/</span> <span class="mi">30</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">temp_i</span><span class="p">)</span>
            <span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">temp_i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">onsets</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">############################# Maximum detector ############################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.DetectMaxima"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.DetectMaxima">[docs]</a>    <span class="k">def</span> <span class="nf">DetectMaxima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">percentile</span><span class="p">:</span> <span class="nb">int</span> <span class="p">,</span><span class="n">hr_win</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">peak_detector</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1">#Table VI pseudocode</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect Maxima function detects all peaks in the raw and also in the filtered signal to find.</span>

<span class="sd">        :param sig: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type sig: 1-d array</span>
<span class="sd">        :param percentile: in each signal partition, a rank filter detects the peaks above a given percentile</span>
<span class="sd">        :type percentile: int</span>
<span class="sd">        :param hr_win: window for adaptive the heart rate estimate</span>
<span class="sd">        :type hr_win: int</span>
<span class="sd">        :param peak_detector: type of peak detector</span>
<span class="sd">        :type peak_detector: str</span>

<span class="sd">        :return: maximum peaks of signal, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">peak_detector</span><span class="o">==</span><span class="s1">&#39;aby&#39;</span><span class="p">:</span>

            <span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s3</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">)))</span>
            <span class="n">max_pks</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">sig</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tr</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">peak_detector</span><span class="o">==</span><span class="s1">&#39;abp&#39;</span><span class="p">:</span>
            <span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">max_loc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">min_loc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">max_pks</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">intensity_v</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">hr_win</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s3</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">)))</span>
                <span class="n">max_pks</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">sig</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tr</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_loc</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">hr_win</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">min_loc</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">sig</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">hr_win</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">max_loc</span><span class="p">)):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">max_loc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_loc</span><span class="p">)</span>
                    <span class="n">min_v</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">min_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_v</span><span class="o">==</span><span class="n">values</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">intensity_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">max_loc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">sig</span><span class="p">[</span><span class="n">min_loc</span><span class="p">[</span><span class="n">min_i</span><span class="p">]])</span>

                <span class="c1"># improvements:</span>
                <span class="c1">#   - adaptive threshold</span>
                <span class="c1">#   - probability density of maximum</span>

                <span class="n">tr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">intensity_v</span><span class="p">)</span><span class="o">*</span><span class="mf">0.25</span>
                <span class="n">max_pks</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">sig</span><span class="o">+</span><span class="nb">min</span><span class="p">(</span><span class="n">sig</span><span class="p">),</span><span class="n">prominence</span><span class="o">=</span><span class="n">tr2</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="n">hr_win</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">max_pks</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">############################ Bandpass filtering ###########################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.Bandpass"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.Bandpass">[docs]</a>    <span class="k">def</span> <span class="nf">Bandpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lower_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">upper_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bandpass filter function detects all peaks in the raw and also in the filtered signal to find.</span>

<span class="sd">        :param sig: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type sig: 1-d array</span>
<span class="sd">        :param fs: sampling frequency</span>
<span class="sd">        :type fs: int</span>
<span class="sd">        :param lower_cutoff: lower cutoff frequency</span>
<span class="sd">        :type lower_cutoff: float</span>
<span class="sd">        :param upper_cutoff: upper cutoff frequency</span>
<span class="sd">        :type upper_cutoff: float</span>

<span class="sd">        :return: bandpass filtered signal, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Filter characteristics: Eliminate VLFs (below resp freqs): For 4bpm cutoff</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">DotMap</span><span class="p">()</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vlf</span><span class="o">.</span><span class="n">Fpass</span> <span class="o">=</span> <span class="mf">1.3</span><span class="o">*</span><span class="n">lower_cutoff</span>   <span class="c1">#in Hz</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vlf</span><span class="o">.</span><span class="n">Fstop</span> <span class="o">=</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">lower_cutoff</span>   <span class="c1">#in Hz</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vlf</span><span class="o">.</span><span class="n">Dpass</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vlf</span><span class="o">.</span><span class="n">Dstop</span> <span class="o">=</span> <span class="mf">0.01</span>

        <span class="c1"># Filter characteristics: Eliminate VHFs (above frequency content of signals)</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Fpass</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">upper_cutoff</span>   <span class="c1">#in Hz</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Fstop</span> <span class="o">=</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">upper_cutoff</span>   <span class="c1">#in Hz</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Dpass</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Dstop</span> <span class="o">=</span> <span class="mf">0.03</span>

        <span class="c1"># perform BPF</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">DotMap</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">sig</span>
        <span class="n">s</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>

        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">iirfilter</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">lower_cutoff</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">upper_cutoff</span><span class="p">],</span> <span class="n">rs</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
                                <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;cheby2&#39;</span><span class="p">)</span>

        <span class="n">bpf_sig</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bpf_sig</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">################### Filter the high frequency components  #################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.elim_vlfs_abd"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.elim_vlfs_abd">[docs]</a>    <span class="k">def</span> <span class="nf">elim_vlfs_abd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">,</span> <span class="n">lower_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function filter the high frequency components.</span>

<span class="sd">        :param s: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type s: 1-d array</span>
<span class="sd">        :param up: setup up parameters of the algorithm</span>
<span class="sd">        :type up: DotMap</span>
<span class="sd">        :param lower_cutoff: lower cutoff frequency</span>
<span class="sd">        :type lower_cutoff: float</span>

<span class="sd">        :return: high frequency filtered signal, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## Filter pre-processed signal to remove frequencies below resp</span>
        <span class="c1"># Adapted from RRest</span>

        <span class="c1">## Eliminate nans</span>
        <span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">)])</span>

        <span class="c1">##Make filter</span>
        <span class="n">fc</span><span class="o">=</span><span class="n">lower_cutoff</span>
        <span class="n">ripple</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vlf</span><span class="o">.</span><span class="n">Dstop</span><span class="p">)</span>
        <span class="n">width</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vlf</span><span class="o">.</span><span class="n">Fpass</span><span class="o">-</span><span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vlf</span><span class="o">.</span><span class="n">Fstop</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">beta</span><span class="p">]</span> <span class="o">=</span> <span class="n">kaiserord</span><span class="p">(</span><span class="n">ripple</span><span class="p">,</span><span class="n">width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fc</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">))</span>
        <span class="n">AMfilter</span> <span class="o">=</span> <span class="n">b</span>

        <span class="n">s_filt</span><span class="o">=</span><span class="n">DotMap</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s_filt</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">AMfilter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
            <span class="n">s_filt</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="o">-</span><span class="n">s_filt</span><span class="o">.</span><span class="n">v</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">s_filt</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">v</span>

        <span class="n">s_filt</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">fs</span>

        <span class="k">return</span> <span class="n">s_filt</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">################### Filter the low frequency components  ##################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.elim_vhfs"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.elim_vhfs">[docs]</a>    <span class="k">def</span> <span class="nf">elim_vhfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">,</span> <span class="n">upper_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function filter the high frequency components.</span>

<span class="sd">        :param s: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type s: 1-d array</span>
<span class="sd">        :param up: setup up parameters of the algorithm</span>
<span class="sd">        :type up: DotMap</span>
<span class="sd">        :param upper_cutoff: lower cutoff frequency</span>
<span class="sd">        :type upper_cutoff: float</span>

<span class="sd">        :return: low frequency filtered signal, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1">## Filter signal to remove VHFs</span>
        <span class="c1"># Adapted from RRest</span>
        <span class="n">s_filt</span> <span class="o">=</span> <span class="n">DotMap</span><span class="p">()</span>

        <span class="c1">##Eliminate nans</span>
        <span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">)])</span>

        <span class="c1">##Check to see if sampling freq is at least twice the freq of interest</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Fpass</span><span class="o">/</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">s_filt</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">v</span>
            <span class="k">return</span>

        <span class="n">fc</span> <span class="o">=</span> <span class="n">upper_cutoff</span>
        <span class="n">ripple</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Dstop</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Fpass</span> <span class="o">-</span> <span class="n">up</span><span class="o">.</span><span class="n">paramSet</span><span class="o">.</span><span class="n">elim_vhf</span><span class="o">.</span><span class="n">Fstop</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">beta</span><span class="p">]</span> <span class="o">=</span> <span class="n">kaiserord</span><span class="p">(</span><span class="n">ripple</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fc</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">))</span>
        <span class="n">AMfilter</span> <span class="o">=</span> <span class="n">b</span>

        <span class="c1">## Remove VHFs</span>
        <span class="n">s_dt</span><span class="o">=</span><span class="n">detrend</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
        <span class="n">s_filt</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">AMfilter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s_dt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s_filt</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">########################### Heart Rate estimation #########################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.EstimateHeartRate"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.EstimateHeartRate">[docs]</a>    <span class="k">def</span> <span class="nf">EstimateHeartRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">,</span> <span class="n">hr_past</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Heart Rate Estimation function estimate the heart rate according to the previous heart rate in given time window</span>

<span class="sd">        :param sig: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type sig: 1-d array</span>
<span class="sd">        :type fs: int</span>
<span class="sd">        :param up: setup up parameters of the algorithm</span>
<span class="sd">        :type up: DotMap</span>
<span class="sd">        :param hr_past: the average heart rate in the past in given time window</span>
<span class="sd">        :type hr_past: int</span>

<span class="sd">        :return: estimated heart rate, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Estimate PSD</span>
        <span class="n">blackman_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">pxx</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span> <span class="n">blackman_window</span><span class="p">)</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="n">pxx</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">f</span>

        <span class="c1"># Extract HR</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hr_past</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">&lt;</span> <span class="n">up</span><span class="o">.</span><span class="n">fl_hz</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">hr_past</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">&gt;</span> <span class="n">up</span><span class="o">.</span><span class="n">fh_hz</span><span class="p">):</span>
            <span class="n">rel_els</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">fh</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="o">.</span><span class="n">fl_hz</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fh</span> <span class="o">&lt;=</span> <span class="n">up</span><span class="o">.</span><span class="n">fh_hz</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rel_els</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">fh</span> <span class="o">&gt;=</span> <span class="n">hr_past</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fh</span> <span class="o">&lt;=</span> <span class="n">hr_past</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">*</span> <span class="mf">1.4</span><span class="p">))</span>

        <span class="n">rel_p</span> <span class="o">=</span> <span class="n">ph</span><span class="p">[</span><span class="n">rel_els</span><span class="p">]</span>
        <span class="n">rel_f</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="n">rel_els</span><span class="p">]</span>
        <span class="n">max_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rel_p</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">rel_p</span><span class="p">))</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="n">rel_f</span><span class="p">[</span><span class="n">max_el</span><span class="p">]</span><span class="o">*</span><span class="mi">60</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">hr</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">############# Estimate derivative from highly filtered signal #############</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.EstimateDeriv"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.EstimateDeriv">[docs]</a>    <span class="k">def</span> <span class="nf">EstimateDeriv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derivative Estimation function estimate derivative from highly filtered signal based on the</span>
<span class="sd">        General least-squares smoothing and differentiation by the convolution (Savitzky Golay) method</span>

<span class="sd">        :param sig: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type sig: 1-d array</span>

<span class="sd">        :return: derivative, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Savitzky Golay</span>
        <span class="n">deriv_no</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">deriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">savitzky_golay_abd</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">deriv_no</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">deriv</span></div>


<div class="viewcode-block" id="FiducialPoints.savitzky_golay_abd"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.savitzky_golay_abd">[docs]</a>    <span class="k">def</span> <span class="nf">savitzky_golay_abd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">deriv_no</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">win_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function estimate the Savitzky Golay derivative from highly filtered signal</span>

<span class="sd">        :param sig: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type sig: 1-d array</span>
<span class="sd">        :param deriv_no: number of derivative</span>
<span class="sd">        :type deriv_no: int</span>
<span class="sd">        :param win_size: size of window</span>
<span class="sd">        :type win_size: int</span>

<span class="sd">        :return: Savitzky Golay derivative, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">##assign coefficients</span>
        <span class="c1"># From: https: // en.wikipedia.org / wiki / Savitzky % E2 % 80 % 93 Golay_filter  # Tables_of_selected_convolution_coefficients</span>
        <span class="c1"># which are calculated from: A., Gorry(1990). &quot;General least-squares smoothing and differentiation by the convolution (Savitzky?Golay) method&quot;.Analytical Chemistry. 62(6): 570?3. doi: 10.1021 / ac00205a007.</span>

        <span class="k">if</span> <span class="n">deriv_no</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1">#smoothing</span>
            <span class="k">if</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">35</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">21</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">231</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Can&#39;&#39;t do this window size&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">deriv_no</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># first derivative</span>
            <span class="k">if</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">28</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">60</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Can&#39;&#39;t do this window size&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">deriv_no</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># second derivative</span>
            <span class="k">if</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">7</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">42</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">28</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">17</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">17</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">28</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">462</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Can&#39;&#39;t do this window size&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">deriv_no</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># third derivative</span>
            <span class="k">if</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">13</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">198</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Can&#39;&#39;t do this window size&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">deriv_no</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># fourth derivative</span>
            <span class="k">if</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">11</span>
            <span class="k">elif</span> <span class="n">win_size</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">143</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Can&#39;&#39;t do this window size&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Can&#39;&#39;t do this order of derivative&#39;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">deriv_no</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">filtered_sig</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
        <span class="c1"># filtered_sig = filtfilt(coeffs, A, sig)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="n">half_win_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">win_size</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">zero_pad</span><span class="o">=</span><span class="n">filtered_sig</span><span class="p">[</span><span class="n">win_size</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">half_win_size</span><span class="p">))</span>
        <span class="n">sig_in</span><span class="o">=</span><span class="n">filtered_sig</span><span class="p">[</span><span class="n">win_size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="p">]</span>
        <span class="n">sig_end</span><span class="o">=</span><span class="n">filtered_sig</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">half_win_size</span><span class="p">))</span>
        <span class="n">deriv</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">zero_pad</span><span class="p">,</span><span class="o">*</span><span class="n">sig_in</span><span class="p">,</span><span class="o">*</span><span class="n">sig_end</span><span class="p">]</span>
        <span class="n">deriv</span> <span class="o">=</span> <span class="n">deriv</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">norm_factor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">deriv</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">############################# Pulse detection #############################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.find_pulse_peaks"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.find_pulse_peaks">[docs]</a>    <span class="k">def</span> <span class="nf">find_pulse_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">p3</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pulse detection function detect the pulse peaks according to the peaks of 1st and 2nd derivatives</span>
<span class="sd">        General least-squares smoothing and differentiation by the convolution (Savitzky Golay) method</span>

<span class="sd">        :param p2: peaks of the 1st derivatives</span>
<span class="sd">        :type p2: 1-d array</span>
<span class="sd">        :param p3: peaks of the 2nd derivatives</span>
<span class="sd">        :type p2: 1-d array</span>

<span class="sd">        :return: pulse peaks, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>
        <span class="n">p4</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">p2</span><span class="p">)):</span>
            <span class="n">rel_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p3</span><span class="o">&gt;</span><span class="n">p2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rel_el</span><span class="p">)</span> <span class="ow">and</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rel_el</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">p4</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">p3</span><span class="p">[</span><span class="n">rel_el</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

        <span class="n">p4</span> <span class="o">=</span> <span class="n">p4</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">p4</span><span class="p">))]</span>
        <span class="n">p4</span> <span class="o">=</span> <span class="n">p4</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p4</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">####################### Correct peaks&#39; location error #####################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.IBICorrect"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.IBICorrect">[docs]</a>    <span class="k">def</span>  <span class="nf">IBICorrect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">hr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function corrects the peaks&#39; location error</span>

<span class="sd">        :param p: systolic peaks of the PPG signal</span>
<span class="sd">        :type p: 1-d array</span>
<span class="sd">        :param m: all maxima of the PPG signal</span>
<span class="sd">        :type m: 1-d array</span>
<span class="sd">        :param hr: heart rate</span>
<span class="sd">        :type hr: float</span>
<span class="sd">        :param fs: sampling frequency</span>
<span class="sd">        :type fs: int</span>
<span class="sd">        :param up: setup up parameters of the algorithm</span>
<span class="sd">        :type up: DotMap</span>

<span class="sd">        :return: onsets, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Correct peaks&#39; location error due to pre-processing</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="n">pc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">pc1</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
            <span class="n">temp_pk</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">rel_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">temp_pk</span><span class="o">==</span><span class="nb">min</span><span class="p">(</span><span class="n">temp_pk</span><span class="p">))</span>
            <span class="n">pc1</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">pc1</span><span class="p">,</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">rel_el</span><span class="p">]]</span>

        <span class="c1"># Correct false positives</span>
        <span class="c1"># identify FPs</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pc1</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span>    <span class="c1"># interbeat intervals in secs</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_reduced_IBIs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">hr</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>

        <span class="c1"># remove FPs</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pc1</span><span class="p">)[</span><span class="n">fp</span><span class="p">]</span>

        <span class="c1"># Correct false negatives</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span>    <span class="c1"># interbeat intervals in secs</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_prolonged_IBIs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">hr</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>

        <span class="n">pc</span> <span class="o">=</span> <span class="n">pc1</span>

        <span class="k">return</span> <span class="n">pc</span><span class="p">,</span> <span class="n">fn</span></div>

<div class="viewcode-block" id="FiducialPoints.find_reduced_IBIs"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.find_reduced_IBIs">[docs]</a>    <span class="k">def</span> <span class="nf">find_reduced_IBIs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">IBIs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">med_hr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function finds the reduced interbeat intervals</span>

<span class="sd">        :param IBIs: interbeat intervals in secs</span>
<span class="sd">        :type IBIs: 1-d array</span>
<span class="sd">        :param med_hr: median heart rate</span>
<span class="sd">        :type med_hr: float</span>
<span class="sd">        :param up: setup up parameters of the algorithm</span>
<span class="sd">        :type up: DotMap</span>

<span class="sd">        :return: fp, the false positive case</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">IBI_thresh</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">lower_hr_thresh_prop</span><span class="o">*</span><span class="mi">60</span><span class="o">/</span><span class="n">med_hr</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">IBIs</span> <span class="o">&lt;</span> <span class="n">IBI_thresh</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">fp</span></div>

<div class="viewcode-block" id="FiducialPoints.find_prolonged_IBIs"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.find_prolonged_IBIs">[docs]</a>    <span class="k">def</span> <span class="nf">find_prolonged_IBIs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IBIs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">med_hr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function finds the prolonged interbeat intervals</span>

<span class="sd">        :param IBIs: interbeat intervals in secs</span>
<span class="sd">        :type IBIs: 1-d array</span>
<span class="sd">        :param med_hr: median heart rate</span>
<span class="sd">        :type med_hr: float</span>
<span class="sd">        :param up: setup up parameters of the algorithm</span>
<span class="sd">        :type up: DotMap</span>

<span class="sd">        :return: fn, the false negative case</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">IBI_thresh</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">upper_hr_thresh_prop</span><span class="o">*</span><span class="mi">60</span><span class="o">/</span><span class="n">med_hr</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">IBIs</span> <span class="o">&gt;</span> <span class="n">IBI_thresh</span>

        <span class="k">return</span> <span class="n">fn</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">####################### Setup up the beat detector ########################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.setup_up_abdp_algorithm"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.setup_up_abdp_algorithm">[docs]</a>    <span class="k">def</span> <span class="nf">setup_up_abdp_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function setups the filter parameters of the algorithm</span>

<span class="sd">        :return: filter parameters of the algorithm, DotMap.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plausible HR limits</span>
        <span class="n">up</span><span class="o">=</span><span class="n">DotMap</span><span class="p">()</span>
        <span class="n">up</span><span class="o">.</span><span class="n">fl</span> <span class="o">=</span> <span class="mi">30</span>               <span class="c1">#lower bound for HR</span>
        <span class="n">up</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="mi">200</span>              <span class="c1">#upper bound for HR</span>
        <span class="n">up</span><span class="o">.</span><span class="n">fl_hz</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">fl</span><span class="o">/</span><span class="mi">60</span>
        <span class="n">up</span><span class="o">.</span><span class="n">fh_hz</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">fh</span><span class="o">/</span><span class="mi">60</span>

        <span class="c1"># Thresholds</span>
        <span class="n">up</span><span class="o">.</span><span class="n">deriv_threshold</span> <span class="o">=</span> <span class="mi">75</span>          <span class="c1">#originally 90</span>
        <span class="n">up</span><span class="o">.</span><span class="n">upper_hr_thresh_prop</span> <span class="o">=</span> <span class="mf">2.25</span>   <span class="c1">#originally 1.75</span>
        <span class="n">up</span><span class="o">.</span><span class="n">lower_hr_thresh_prop</span> <span class="o">=</span> <span class="mf">0.5</span>    <span class="c1">#originally 0.75</span>

        <span class="c1"># Other parameters</span>
        <span class="n">up</span><span class="o">.</span><span class="n">win_size</span> <span class="o">=</span> <span class="mi">10</span>    <span class="c1">#in secs</span>

        <span class="k">return</span> <span class="n">up</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">############################## Find PPG onsets ############################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.find_onsets"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.find_onsets">[docs]</a>    <span class="k">def</span> <span class="nf">find_onsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">up</span><span class="p">:</span> <span class="n">DotMap</span><span class="p">,</span> <span class="n">peaks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">med_hr</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function finds the onsets of PPG sigal</span>

<span class="sd">        :param sig: array of signal with shape (N,) where N is the length of the signal</span>
<span class="sd">        :type sig: 1-d array</span>
<span class="sd">        :param fs: sampling frequency</span>
<span class="sd">        :type fs: int</span>
<span class="sd">        :param up: setup up parameters of the algorithm</span>
<span class="sd">        :type up: DotMap</span>
<span class="sd">        :param peaks: peaks of the signal</span>
<span class="sd">        :type peaks: 1-d array</span>
<span class="sd">        :param med_hr: median heart rate</span>
<span class="sd">        :type med_hr: float</span>

<span class="sd">        :return: onsets, 1-d array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Y1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Bandpass</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mf">0.9</span><span class="o">*</span><span class="n">up</span><span class="o">.</span><span class="n">fl_hz</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">up</span><span class="o">.</span><span class="n">fh_hz</span><span class="p">)</span>
        <span class="n">temp_oi0</span><span class="o">=</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">Y1</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="n">med_hr</span><span class="o">*</span><span class="mf">0.3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">null_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">temp_oi0</span><span class="o">&lt;</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">null_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">null_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">onsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">null_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">onsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">null_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">onsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">round</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">50</span><span class="p">)]</span>

        <span class="n">i</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
            <span class="n">min_SUT</span><span class="o">=</span><span class="n">fs</span><span class="o">*</span><span class="mf">0.12</span>     <span class="c1"># minimum Systolic Upslope Time 120 ms</span>
            <span class="n">min_DT</span><span class="o">=</span><span class="n">fs</span><span class="o">*</span><span class="mf">0.3</span>       <span class="c1"># minimum Diastolic Time 300 ms</span>

            <span class="n">before_peak</span><span class="o">=</span><span class="n">temp_oi0</span> <span class="o">&lt;</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">after_last_onset</span><span class="o">=</span><span class="n">temp_oi0</span> <span class="o">&gt;</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">SUT_time</span><span class="o">=</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">temp_oi0</span><span class="o">&gt;</span><span class="n">min_SUT</span>
            <span class="n">DT_time</span> <span class="o">=</span> <span class="n">temp_oi0</span><span class="o">-</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">&gt;</span> <span class="n">min_DT</span>
            <span class="n">temp_oi1</span> <span class="o">=</span> <span class="n">temp_oi0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">before_peak</span> <span class="o">*</span> <span class="n">after_last_onset</span><span class="o">*</span><span class="n">SUT_time</span><span class="o">*</span><span class="n">DT_time</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_oi1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_oi1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">onsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_oi1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">onsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_oi1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">onsets</span><span class="p">,</span><span class="n">peaks</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">########################## Detect dicrotic notch ##########################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.getDicroticNotch"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.getDicroticNotch">[docs]</a>    <span class="k">def</span> <span class="nf">getDicroticNotch</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">onsets</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dicrotic Notch function estimate the location of dicrotic notch in between the systolic and diastolic peak</span>

<span class="sd">        :param peaks: peaks of the signal</span>
<span class="sd">        :type peaks: 1-d array</span>
<span class="sd">        :param onsets: onsets of the signal</span>
<span class="sd">        :type onsets: list</span>

<span class="sd">        :return: location of dicrotic notches, 1-d array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## The 2nd derivative and Hamming low pass filter is calculated.</span>
        <span class="n">dxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">))</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span>

        <span class="c1"># Make filter</span>
        <span class="n">Fn</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>                                 <span class="c1"># Nyquist Frequency</span>
        <span class="n">FcU</span> <span class="o">=</span> <span class="mi">20</span>                                    <span class="c1"># Cut off Frequency: 20 Hz</span>
        <span class="n">FcD</span> <span class="o">=</span> <span class="n">FcU</span> <span class="o">+</span> <span class="mi">5</span>                               <span class="c1"># Transition Frequency: 5 Hz</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mi">21</span>                                      <span class="c1"># Filter order</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">FcU</span> <span class="o">/</span> <span class="n">Fn</span><span class="p">),</span> <span class="p">(</span><span class="n">FcD</span> <span class="o">/</span> <span class="n">Fn</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span>          <span class="c1"># Frequency band edges</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>                            <span class="c1"># Amplitudes</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">firls</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="n">lp_filt_sig</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="n">dxx</span><span class="p">)</span>    <span class="c1"># Low pass filtered signal with 20 cut off Frequency and 5 Hz Transition width</span>

        <span class="c1">## The weighting is calculated and applied to each beat individually</span>
        <span class="k">def</span> <span class="nf">t_wmax</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span><span class="n">onsets</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">HR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">peaks</span><span class="p">))</span><span class="o">/</span><span class="n">fs</span>
                <span class="n">t_wmax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">HR</span> <span class="o">+</span> <span class="mf">0.45</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_wmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">:</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">fs</span>
            <span class="k">return</span> <span class="n">t_wmax</span>

        <span class="n">dic_not</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">nth_beat</span> <span class="o">=</span> <span class="n">lp_filt_sig</span><span class="p">[</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">i_Pmax</span><span class="o">=</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">t_Pmax</span><span class="o">=</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">fs</span>
            <span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nth_beat</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nth_beat</span><span class="p">))</span><span class="o">/</span><span class="n">fs</span>
            <span class="n">T_beat</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nth_beat</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span>
            <span class="n">tau</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t_Pmax</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">T_beat</span><span class="o">-</span><span class="n">t_Pmax</span><span class="p">)</span>
            <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i_Pmax</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">beta</span><span class="o">=</span><span class="mi">5</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">t_w</span><span class="o">=</span><span class="n">t_wmax</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">onsets</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

            <span class="k">if</span> <span class="n">t_w</span><span class="o">!=</span><span class="n">T_beat</span><span class="p">:</span>
                <span class="n">tau_wmax</span><span class="o">=</span><span class="p">(</span><span class="n">t_w</span><span class="o">-</span><span class="n">t_Pmax</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">T_beat</span><span class="o">-</span><span class="n">t_Pmax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tau_wmax</span><span class="o">=</span><span class="mf">0.9</span>

            <span class="n">alfa</span><span class="o">=</span><span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">tau_wmax</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau_wmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">tau_wmax</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alfa</span> <span class="o">&gt;</span> <span class="mf">4.5</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">alfa</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">):</span>
                <span class="n">HR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">peaks</span><span class="p">))</span><span class="o">/</span><span class="n">fs</span>
                <span class="n">t_w</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">HR</span> <span class="o">+</span> <span class="mf">0.45</span>
                <span class="n">tau_wmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_w</span> <span class="o">-</span> <span class="n">t_Pmax</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">T_beat</span> <span class="o">-</span> <span class="n">t_Pmax</span><span class="p">)</span>
                <span class="n">alfa</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tau_wmax</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tau_wmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau_wmax</span><span class="p">)</span>

            <span class="c1">## Calculate the Dicrotic Notch for each heart cycle using the weighted window</span>
            <span class="k">if</span> <span class="n">alfa</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">**</span> <span class="p">(</span><span class="n">alfa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">pp</span><span class="o">=</span><span class="n">w</span><span class="o">*</span><span class="n">nth_beat</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">pp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pp</span><span class="p">))]</span>
            <span class="n">max_pp_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
            <span class="n">max_pp_i</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pp</span><span class="o">==</span><span class="n">max_pp_v</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">## NOTE!! Shifting with 26 ms. FIX IT!</span>
            <span class="n">shift</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">*</span><span class="mf">0.026</span><span class="p">)</span>
            <span class="n">dic_not</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_pp_i</span><span class="o">+</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">shift</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dic_not</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">########################## Detect diastolic peak ##########################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.getDiastolicPeak"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.getDiastolicPeak">[docs]</a>    <span class="k">def</span> <span class="nf">getDiastolicPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onsets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">dicroticnotch</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">e_point</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dicrotic Notch function estimate the location of dicrotic notch in between the systolic and diastolic peak</span>

<span class="sd">        :param onsets: onsets of the signal</span>
<span class="sd">        :type onsets: list</span>
<span class="sd">        :param dicroticnotches: dicrotic notches of the signal</span>
<span class="sd">        :type dicroticnotches: list</span>
<span class="sd">        :param e_point: e-points of the signal</span>
<span class="sd">        :type e_point: pd.Series</span>

<span class="sd">        :return diastolicpeak: location of dicrotic notches, 1-d array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nan_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dicroticnotch</span><span class="p">))</span>
        <span class="n">nan_v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">diastolicpeak</span> <span class="o">=</span> <span class="n">nan_v</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">dicroticnotch</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">len_segments</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">*</span><span class="mf">0.80</span>
                <span class="n">end_segment</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">len_segments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">start_segment</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dicroticnotch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">temp_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">[</span><span class="n">start_segment</span><span class="p">:</span><span class="n">end_segment</span><span class="p">]</span>
                    <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_locs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">start_segment</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e_point</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">temp_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_d1</span><span class="p">[</span><span class="n">start_segment</span><span class="p">:</span><span class="n">end_segment</span><span class="p">]</span>
                        <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>

                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="n">max_dn</span> <span class="o">=</span> <span class="n">max_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">start_segment</span>
                <span class="n">diastolicpeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_dn</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">diastolicpeak</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">####################### Get First Derivitive Points #######################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.getFirstDerivitivePoints"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.getFirstDerivitivePoints">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstDerivitivePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onsets</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate first derivitive points u and v from the PPG&#39; signal</span>

<span class="sd">        :param onsets: onsets of the signal</span>
<span class="sd">        :type onsets: list</span>

<span class="sd">        :return:</span>
<span class="sd">            - u: The highest amplitude between the pulse onset and systolic peak on PPG&#39;</span>
<span class="sd">            - v: The lowest amplitude between the u-point and diastolic peak on PPG&#39;</span>
<span class="sd">            - w: The first local maximum or inflection point after the dicrotic notch on PPG’</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_d1</span>

        <span class="n">nan_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nan_v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">segment</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

                <span class="c1"># u fiducial point</span>
                <span class="n">max_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span><span class="o">+</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">max_loc</span>

                <span class="c1"># v fiducial point</span>
                <span class="n">upper_bound_coeff</span> <span class="o">=</span> <span class="mf">0.66</span>
                <span class="n">v_upper_bound</span> <span class="o">=</span> <span class="p">((</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">upper_bound_coeff</span> <span class="o">+</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">min_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="n">v_upper_bound</span><span class="p">])</span><span class="o">+</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_loc</span>

                <span class="c1"># w fiducial point</span>
                <span class="n">temp_segment</span><span class="o">=</span><span class="n">dx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="n">max_w</span> <span class="o">=</span> <span class="n">max_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_w</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">drt1_fp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;u&quot;</span><span class="p">:[],</span> <span class="s2">&quot;v&quot;</span><span class="p">:[],</span> <span class="s2">&quot;w&quot;</span><span class="p">:[]})</span>
        <span class="n">drt1_fp</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">drt1_fp</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">drt1_fp</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span>
        <span class="k">return</span> <span class="n">drt1_fp</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1">####################### Get Second Derivitive Points ######################</span>
    <span class="c1">###########################################################################</span>
<div class="viewcode-block" id="FiducialPoints.getSecondDerivitivePoints"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.getSecondDerivitivePoints">[docs]</a>    <span class="k">def</span> <span class="nf">getSecondDerivitivePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onsets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">peaks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate Second derivitive points a, b, c, d, e, and f from the PPG&quot; signal</span>

<span class="sd">        :param onsets: onsets of the signal</span>
<span class="sd">        :type onsets: list</span>
<span class="sd">        :param peaks: peaks of the signal</span>
<span class="sd">        :param types: 1-d array</span>

<span class="sd">        :return:</span>
<span class="sd">            - a: The highest amplitude between pulse onset and systolic peak on PPG&quot;</span>
<span class="sd">            - b: The first local minimum after the a-point on PPG&quot;</span>
<span class="sd">            - c: The local maximum with the highest amplitude between the b-point and e-point, or if no local maximum is present then the inflection point on PPG&quot;</span>
<span class="sd">            - d: The local minimum with the lowest amplitude between the c-point and e-point, or if no local minimum is present then the inflection point on PPG&quot;</span>
<span class="sd">            - e: The local maximum with the highest amplitude after the b-point and before the diastolic peak on PPG&quot;</span>
<span class="sd">            - f: The first local minimum after the e-point on PPG&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span>
        <span class="n">ddx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_d2</span>
        <span class="n">dddx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_d3</span>

        <span class="n">nan_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nan_v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># a fiducial point</span>
                <span class="n">temp_pk</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span><span class="o">+</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">temp_segment</span><span class="o">=</span><span class="n">ddx</span><span class="p">[</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">temp_pk</span><span class="p">]</span>
                <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">max_loc</span> <span class="o">=</span> <span class="n">max_locs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">[</span><span class="n">max_locs</span><span class="p">])]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">max_loc</span> <span class="o">=</span> <span class="n">temp_segment</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

                <span class="n">max_a</span> <span class="o">=</span> <span class="n">max_loc</span> <span class="o">+</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_a</span>

                <span class="c1"># b fiducial point</span>
                <span class="n">temp_segment</span><span class="o">=</span><span class="n">ddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">min_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="n">min_b</span> <span class="o">=</span> <span class="n">min_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_b</span>

                <span class="c1"># e fiducial point</span>
                <span class="n">e_lower_bound</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">upper_bound_coeff</span> <span class="o">=</span> <span class="mf">0.6</span>
                <span class="n">e_upper_bound</span> <span class="o">=</span> <span class="p">((</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">upper_bound_coeff</span> <span class="o">+</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">temp_segment</span><span class="o">=</span><span class="n">ddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">e_lower_bound</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">e_upper_bound</span><span class="p">)]</span>
                <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">max_locs</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">temp_segment</span><span class="o">=</span><span class="n">ddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">max_loc</span> <span class="o">=</span> <span class="n">max_locs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">[</span><span class="n">max_locs</span><span class="p">])]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">max_loc</span> <span class="o">=</span> <span class="n">temp_segment</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

                <span class="n">max_e</span> <span class="o">=</span> <span class="n">max_loc</span> <span class="o">+</span> <span class="n">e_lower_bound</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_e</span>

                <span class="c1"># c fiducial point</span>
                <span class="n">temp_segment</span> <span class="o">=</span> <span class="n">ddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">max_locs</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">max_loc</span> <span class="o">=</span> <span class="n">max_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">temp_segment</span> <span class="o">=</span> <span class="n">dddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                    <span class="n">min_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">temp_segment</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">min_locs</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">max_loc</span> <span class="o">=</span> <span class="n">min_locs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">[</span><span class="n">min_locs</span><span class="p">])]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">max_loc</span> <span class="o">=</span> <span class="n">max_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">max_loc</span> <span class="o">=</span> <span class="n">temp_segment</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

                <span class="n">max_c</span> <span class="o">=</span> <span class="n">max_loc</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_c</span>

                <span class="c1"># d fiducial point</span>
                <span class="n">temp_segment</span> <span class="o">=</span> <span class="n">ddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                <span class="n">min_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">min_locs</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">min_loc</span> <span class="o">=</span> <span class="n">min_locs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">[</span><span class="n">min_locs</span><span class="p">])]</span>
                    <span class="n">min_d</span> <span class="o">=</span> <span class="n">min_loc</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">min_d</span> <span class="o">=</span> <span class="n">max_c</span>

                <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_d</span>

                <span class="c1"># f fiducial point</span>
                <span class="n">temp_segment</span> <span class="o">=</span> <span class="n">ddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">min_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">min_locs</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">min_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">*</span><span class="mf">0.8</span><span class="p">):</span>
                    <span class="n">min_loc</span> <span class="o">=</span> <span class="n">min_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">min_loc</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">min_f</span> <span class="o">=</span> <span class="n">min_loc</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_f</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">drt2_fp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:[],</span> <span class="s2">&quot;b&quot;</span><span class="p">:[],</span> <span class="s2">&quot;c&quot;</span><span class="p">:[],</span><span class="s2">&quot;d&quot;</span><span class="p">:[],</span> <span class="s2">&quot;e&quot;</span><span class="p">:[],</span> <span class="s2">&quot;f&quot;</span><span class="p">:[]})</span>
        <span class="n">drt2_fp</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">drt2_fp</span></div>

<div class="viewcode-block" id="FiducialPoints.getThirdDerivitivePoints"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.getThirdDerivitivePoints">[docs]</a>    <span class="k">def</span> <span class="nf">getThirdDerivitivePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onsets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">drt2_fp</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate third derivitive points p1 and p2 from the PPG&#39;&quot; signal</span>

<span class="sd">            :param onsets: onsets of the signal</span>
<span class="sd">            :type onsets: list</span>
<span class="sd">            :param drt2_fp: fiducial points of PPG&quot; signal</span>
<span class="sd">            :type drt2_fp: DataFrame</span>

<span class="sd">            :return:</span>
<span class="sd">                - p1: The first local maximum after the b-point on PPG&#39;&quot;</span>
<span class="sd">                - p2: The last local minimum after the b-point and before the d-point on PPG&#39;&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dddx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_d3</span>

        <span class="n">nan_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nan_v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">),</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nan_v</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># p1 fiducial point</span>
                <span class="n">ref_b</span> <span class="o">=</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">drt2_fp</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))]</span>
                <span class="k">if</span> <span class="n">ref_b</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ref_b</span> <span class="o">=</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">temp_segment</span> <span class="o">=</span> <span class="n">dddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ref_b</span><span class="p">):</span><span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">max_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">max_loc</span> <span class="o">=</span> <span class="n">max_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">max_loc</span> <span class="o">=</span> <span class="n">temp_segment</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

                <span class="n">max_p1</span> <span class="o">=</span> <span class="n">max_loc</span> <span class="o">+</span> <span class="n">ref_b</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_p1</span>

                <span class="c1"># p2 fiducial point</span>
                <span class="n">ref_start</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ref_c</span> <span class="o">=</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">drt2_fp</span><span class="o">.</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))]</span>
                <span class="n">ref_d</span> <span class="o">=</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">drt2_fp</span><span class="o">.</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))]</span>

                <span class="k">if</span> <span class="n">ref_d</span> <span class="o">&gt;</span> <span class="n">ref_c</span><span class="p">:</span>
                    <span class="n">ref_end</span> <span class="o">=</span> <span class="n">ref_d</span>
                    <span class="n">min_ind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">elif</span> <span class="n">ref_c</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ref_start</span> <span class="o">=</span> <span class="n">ref_c</span>
                    <span class="n">ref_end</span> <span class="o">=</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">drt2_fp</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ref_end</span> <span class="o">=</span> <span class="n">onsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_ind</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">temp_segment</span> <span class="o">=</span> <span class="n">dddx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ref_start</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">ref_end</span><span class="p">)]</span>
                <span class="n">min_locs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">temp_segment</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">min_locs</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">min_p2</span> <span class="o">=</span> <span class="n">min_locs</span><span class="p">[</span><span class="n">min_ind</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_start</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">min_p2</span> <span class="o">=</span> <span class="n">ref_end</span>

                <span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_p2</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">drt3_fp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;p1&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;p2&quot;</span><span class="p">:</span> <span class="p">[]})</span>
        <span class="n">drt3_fp</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">drt3_fp</span><span class="o">.</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span>

        <span class="k">return</span> <span class="n">drt3_fp</span></div>

<div class="viewcode-block" id="FiducialPoints.CorrectFiducialPoints"><a class="viewcode-back" href="../../pyPPG.html#pyPPG.FiducialPoints.FiducialPoints.CorrectFiducialPoints">[docs]</a>    <span class="k">def</span> <span class="nf">CorrectFiducialPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fiducials</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correct the Fiducial Points</span>

<span class="sd">            :param fiducials: a dictionary where the key is the name of the fiducial pints and the value is the list of fiducial points.</span>
<span class="sd">            :type fiducials: DataFrame</span>

<span class="sd">            :return:</span>
<span class="sd">                - fiducials: a dictionary where the key is the name of the fiducial pints and the value is the list of fiducial points.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">)):</span>

            <span class="c1"># Correct onset</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">win_onr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">*</span> <span class="mf">0.005</span>
                <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">win_onr</span><span class="p">:</span>
                    <span class="n">win_onl</span> <span class="o">=</span> <span class="n">win_onr</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">win_onl</span> <span class="o">=</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">min_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">[</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">win_onl</span><span class="p">:</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">win_onr</span><span class="p">])</span> <span class="o">+</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">min_loc</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">*</span><span class="mf">0.075</span><span class="p">:</span>
                        <span class="n">win_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">*</span><span class="mf">0.075</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">win_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                    <span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_d3</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">win_a</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">win_a</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Correct dicrotic notch</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">temp_segment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                <span class="n">min_dn</span><span class="o">=</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">temp_segment</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">fiducials</span><span class="o">.</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">diff_dn</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">min_dn</span><span class="o">-</span><span class="n">fiducials</span><span class="o">.</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_dn</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">diff_dn</span><span class="o">&gt;</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">/</span><span class="mi">100</span><span class="p">):</span>
                    <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">min_dn</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">strt_dn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">stp_dn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_sig</span><span class="p">[</span><span class="n">strt_dn</span><span class="p">:</span><span class="n">stp_dn</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">strt_dn</span>
                        <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min_dn</span><span class="p">:</span>
                            <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_dn</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">strt_dn</span> <span class="o">=</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">stp_dn</span> <span class="o">=</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_d3</span><span class="p">[</span><span class="n">strt_dn</span><span class="p">:</span><span class="n">stp_dn</span><span class="p">])</span><span class="o">+</span><span class="n">strt_dn</span>
                        <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min_dn</span><span class="p">:</span>
                            <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_dn</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Correct v and w-point</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">fiducials</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_d1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">fiducials</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_d1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Correct w-point</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">temp_end</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">0.8</span><span class="p">)</span>
                <span class="n">temp_segment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_d1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">temp_end</span><span class="p">)]</span>
                <span class="n">min_w</span><span class="o">=</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">temp_segment</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">fiducials</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_d1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># if fiducials.w[i] &gt; fiducials.f[i]:</span>
                <span class="c1">#     fiducials.w[i] = int(fiducials.f[i])</span>

                <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min_w</span><span class="p">:</span>
                    <span class="n">fiducials</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_w</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Correct f-point</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">temp_end</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">0.8</span><span class="p">)</span>
                <span class="n">temp_segment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_d2</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">temp_end</span><span class="p">)]</span>
                <span class="n">min_f</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">temp_segment</span><span class="p">)</span><span class="o">+</span><span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">fiducials</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_f</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>


        <span class="c1"># Correct diastolic peak</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fiducials</span><span class="o">.</span><span class="n">dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDiastolicPeak</span><span class="p">(</span><span class="n">fiducials</span><span class="o">.</span><span class="n">on</span><span class="p">,</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">dn</span><span class="p">,</span> <span class="n">fiducials</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">fiducials</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Marton A. GODA, PhD.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>